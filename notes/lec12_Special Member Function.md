###  Special Member Functions (SMFs)

* A **constructor** is called every time a new instance of the class is created, and the destructor is called when it **goes out of scope**

```c++
These functions are generated only when they're called (and before any are explicitly defined by you):
We don’t have to write out any of these! They all have default versions that are generated automatically!
    
● Default constructor: T()
● Destructor: ~T()

● Copy constructor: T(const T&)
// It's a **constructor**
Widget widgetOne;
Widget widgetTwo = widgetOne;

● Copy assignment operator: T& operator=(const T&)
// Assigns an already existing object to another
// Note that here both objects **are constructed** before the use of the = operator
Widget widgetOne;
Widget widgetTwo;
widgetOne = widgetTwo

● Move constructor: T(T&&)

● Move assignment operator: T& operator=(T&&)
```

##### Copy and copy assignment

* Initializer Lists

  * ```c++
    template <typename T>
    Vector<T>::Vector() : _size(0), _capacity(4), _data(new T[_capacity]) { }
    ```

  * It’s quicker and more efficient to directly construct member variables with intended values

  * Can be used for any constructor, even non-default ones with parameters!

* What if the variable is a non-assignable type?

  * ```c++
    template <typename T>
    class MyClass {
     const int _constant;
     int& _reference;
    public:
     // Only way to initialize const and reference members
     MyClass(int value, int& ref) : _constant(value), _reference(ref) { }
    };
    ```

  * This code only works with initializer lists

  * page 33-34

    > There are two steps happening here: the first is that _size, _capacity, and _data may have been **default initialized**

###### Why overloads SMFs?

* This is member-wise copying, It's won't work well with manually allocated memory like pointers.
* We want to create a copy that does more than just copies the member variables
* We will want to make a **deep copy**
  * Deep copy: an object that is a complete, independent copy of the original
* So we'd want to override it.

##### default & delete

delete:

* We can delete special member functions, here to prevent copy

  * Setting a special member function to delete removes its functionality!

  * ```c++
    class IntVec{
    public:
    	IntVec();
    	IntVec(const IntVec& other);
    	~IntVec();
    	// ...
    	IntVec(const IntVec& rhs) = delete;
    	IntVec& operator=(const IntVec& rhs) = delete; // Now copying isn’t a possible operation!
    private:
    	...
    }
    ```

* Why?

  * We can selectively allow functionality of special member functions!
  * This has lots of uses – what if we only want one copy of an instance to be allowed?
  * This is how classes like` std::unique_ptr` work

default:

* 

##### Rules

* Rules of Zero: If the default SMFs work, don’t define your own!

  * We should only define new ones when the default ones generated by the compiler won't work
    * This usually happens when we work with dynamically allocated memory, like pointers to things on the heap.

  * If you don’t need a constructor or a destructor or copy assignment etc. Then simply don’t use it! 

* If your class relies on objects/classes that already have these SMFs implemented, then there’s no need to reimplement this logic!

* If you need a custom destructor, then you also probably need to define a copy constructor and a copy assignment operator for your class 

  * If you use a destructor, that often means that you are manually dealing with dynamic memory allocation/are generally just handling your own memory. 
  * Here, The compiler will not be able to automatically generate these for you, because of the manual memory management.